<?php
declare(strict_types=1);

namespace Daylog\Tests\Support\Helper;

use Daylog\Domain\Services\UuidGenerator;
use Daylog\Domain\Services\Clock;
use DateTimeImmutable;

/**
 * Test data builder for Entry in camelCase shape (Application-wide, except Storage).
 *
 * Scenarios:
 * - Use getOne() to produce a single DTO-like payload for validators and use-cases.
 * - Use getMany() to build N items by reusing getOne() (no duplication).
 */
final class EntryTestData
{
    private const DEFAULT_DATE  = '2025-02-12';
    private const DEFAULT_TITLE = 'Valid title';
    private const DEFAULT_BODY  = 'Valid body';

    /**
     * Build a single payload representing an Entry.
     *
     * The method generates a deterministic payload with explicit fields.
     * If $createdAt/$updatedAt are not provided, they are derived from $date (00:00:00).
     *
     * @param string      $title     Non-empty trimmed title (see BR-1/BR-3).
     * @param string      $body      Non-empty body within limits (see BR-2).
     * @param string      $date      Logical date YYYY-MM-DD (see ENTRY-BR-4).
     * @param string|null $createdAt Optional timestamp ISO-8601-like "YYYY-MM-DD HH:MM:SS".
     * @param string|null $updatedAt Optional timestamp ISO-8601-like "YYYY-MM-DD HH:MM:SS".
     * @return array{
     *      id:string, 
     *      title:string, 
     *      body:string, 
     *      date:string, 
     *      createdAt:string, 
     *      updatedAt:string
     * }
     */
    public static function getOne(
        string $title = self::DEFAULT_TITLE,
        string $body  = self::DEFAULT_BODY,
        string $date  = self::DEFAULT_DATE,
        ?string $createdAt = null,
        ?string $updatedAt = null
    ): array {
        $defaultTs = Clock::now();

        $finalCreatedAt = $createdAt ?? $defaultTs;
        $finalUpdatedAt = $updatedAt ?? $finalCreatedAt;

        $id = UuidGenerator::generate();

        $payload = [
            'id'        => $id,
            'title'     => $title,
            'body'      => $body,
            'date'      => $date,
            'createdAt' => $finalCreatedAt,
            'updatedAt' => $finalUpdatedAt,
        ];

        return $payload;
    }

    /**
     * Build many payloads by delegating to getOne() to avoid duplication.
     *
     * Dates are generated by adding $stepDays per subsequent item (deterministic).
     * Use this for pagination/query/sort tests where only shape matters.
     *
     * @param int    $count     Number of items to generate (>= 1).
     * @param int    $stepDays  Day step between consecutive dates (can be 0).
     * @param string $title     Base title for all items.
     * @param string $body      Base body for all items.
     * @param string $startDate Starting logical date YYYY-MM-DD.
     * @return array<int, array{
     *      id:string, 
     *      title:string, 
     *      body:string, 
     *      date:string, 
     *      createdAt:string, 
     *      updatedAt:string
     * }>
     */
    public static function getMany(
        int $count,
        int $stepDays     = 0,
        string $title     = self::DEFAULT_TITLE,
        string $body      = self::DEFAULT_BODY,
        string $startDate = self::DEFAULT_DATE
    ): array {
        $items = [];

        $dateBase = new DateTimeImmutable($startDate);

        // fix base time to avoid midnight rollover in tests
        $baseTime = sprintf('%s 10:00:00', $startDate);
        $baseTime = new DateTimeImmutable($baseTime);

        for ($i = 0; $i < $count; $i++) {
            $dateShift = sprintf('+%s days', $i * $stepDays);
            $dateShift = $dateBase->modify($dateShift);
            $dateValue = $dateShift->format('Y-m-d');

            $timeShift = sprintf('+%s seconds', $i);
            $createdAt = $baseTime->modify($timeShift)->format('Y-m-d H:i:s');
            $updatedAt = $createdAt;                  
            var_dump($createdAt);

            $one = self::getOne($title, $body, $dateValue, $createdAt, $updatedAt);
            $items[] = $one;
        }

        return $items;
    }
}